% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adm_predict.R
\name{adm_predict}
\alias{adm_predict}
\title{Spatial predictions from individual and ensemble models}
\usage{
adm_predict(
  models,
  pred,
  training_data = NULL,
  invert_transform = NULL,
  nchunk = 1,
  predict_area = NULL,
  transform_negative = FALSE
)
}
\arguments{
\item{models}{list of one or more models fitted with fit_ or tune_ functions. In case use models fitted with fit_ensemble or esm_ family function only one model could be used. Usage models = mglm or models = list(mglm, mraf, mgbm)}

\item{pred}{SpatRaster. Raster layer with predictor variables. Names of layers must exactly
match those used in model fitting.}

\item{training_data}{data.frame or tibble. Data used to fit the models. It is necessary
to predict GAM and GLM models. Default NULL}

\item{nchunk}{integer. Number of chunks to split data used to predict models (i.e., SpatRaster
used in pred argument). Predicting models in chunks helps reduce memory requirements in cases
where models are predicted for large scales and high resolution. Default = 1}

\item{predict_area}{SpatVector, SpatialPolygon, or SpatialPolygonDataFrame. Spatial polygon
used for restring prediction into only a given region. Default = NULL}

\item{transform_negative}{logical. If TRUE, all negative values in the prediction will be set to zero.
default FALSE.}
}
\value{
A list of SpatRaster with continuous and/or binary predictions
}
\description{
This function allows the geographical prediction of one or more models constructed
with the fit_ or tune_ function set, models fitted with esm_ function set (i.e., ensemble of
small models approach), or models constructed with fit_ensemble function. It can return
continuous or continuous and binary predictions for one or more thresholds
}
\examples{
\dontrun{
require(dplyr)
require(terra)

data("sppabund")
envar <- system.file("external/envar.tif", package = "adm")
envar <- terra::rast(envar)

# Extract data
some_sp <- sppabund \%>\%
  dplyr::filter(species == "Species one") \%>\%
  dplyr::select(species, ind_ha, x, y)

some_sp

some_sp <-
  adm_extract(
    data = some_sp,
    x = "x",
    y = "y",
    env_layer = envar
  )

# Partition
some_sp <- flexsdm::part_random(
  data = some_sp,
  pr_ab = "ind_ha",
  method = c(method = "rep_kfold", folds = 3, replicates = 3)
)


## \%######################################################\%##
#                                                          #
####          Create different type of models           ####
#                                                          #
## \%######################################################\%##
# Fit some models
# require(gamlss)
# m1 <- gamlss::fitDist(some_sp$ind_ha, type="realline")
# m1$fits
# m1$failed
#
# m1 <- gamlss(ind_ha ~ pb(elevation) + pb(sand) + pb(bio3) + pb(bio12), family=NO, data=some_sp)
# choosen_dist <- gamlss::chooseDist(m1, parallel="snow", ncpus=4, type="realAll")

mgam <- fit_abund_gam(
  data = some_sp,
  response = "ind_ha",
  predictors = c("elevation", "sand", "bio3", "bio12"),
  predictors_f = "eco",
  partition = ".part",
  distribution = gamlss.dist::NO()
)

mraf <- fit_abund_raf(
  data = some_sp,
  response = "ind_ha",
  predictors = c("elevation", "sand", "bio3", "bio12"),
  partition = ".part",
)

mgbm <- fit_abund_gbm(
  data = some_sp,
  response = "ind_ha",
  predictors = c("elevation", "sand", "bio3", "bio12"),
  partition = ".part",
  distribution =
  )


## \%######################################################\%##
#                                                          #
####            ' ####      Predict models              ####
#                                                          #
## \%######################################################\%##

# adm_predict can be used for predict one or more models fitted with fit_ or tune_ functions

# a single model
ind_p <- sdm_predict(
  models = mglm,
  pred = somevar,
  thr = "max_fpb",
  con_thr = FALSE,
  predict_area = NULL
)

# a list of models
list_p <- sdm_predict(
  models = list(mglm, mraf, mgbm),
  pred = somevar,
  thr = "max_fpb",
  con_thr = FALSE,
  predict_area = NULL
)

# Predict an ensemble model
# (only is possilbe use one fit_ensemble)
ensemble_p <- sdm_predict(
  models = mensemble,
  pred = somevar,
  thr = "max_fpb",
  con_thr = FALSE,
  predict_area = NULL
)

# Predict an ensemble of small models
# (only is possible to use one ensemble of small models)
small_p <- sdm_predict(
  models = msmall,
  pred = somevar,
  thr = "max_fpb",
  con_thr = FALSE,
  predict_area = NULL
)

## \%######################################################\%##
#                                                          #
####              Predict model using chunks            ####
#                                                          #
## \%######################################################\%##
# Predicting models in chunks helps reduce memory requirements in
# cases where models are predicted for large scales and high resolution

ind_p <- sdm_predict(
  models = mglm,
  pred = somevar,
  thr = "max_fpb",
  con_thr = FALSE,
  predict_area = NULL,
  nchunk = 4
)
}

}
